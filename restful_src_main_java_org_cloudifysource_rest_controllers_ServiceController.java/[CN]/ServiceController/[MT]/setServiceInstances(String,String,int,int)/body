{
  Map<String,Object> returnMap=new HashMap<String,Object>();
  final String puName=ServiceUtils.getAbsolutePUName(applicationName,serviceName);
  ProcessingUnit pu=admin.getProcessingUnits().getProcessingUnit(puName);
  if (pu == null) {
    return errorStatus(ResponseConstants.FAILED_TO_LOCATE_SERVICE,serviceName);
  }
  Properties contextProperties=pu.getBeanLevelProperties().getContextProperties();
  final String elasticProp=contextProperties.getProperty(CloudifyConstants.CONTEXT_PROPERTY_ELASTIC);
  final String templateName=contextProperties.getProperty(CloudifyConstants.CONTEXT_PROPERTY_TEMPLATE);
  if (elasticProp == null || !Boolean.parseBoolean(elasticProp)) {
    return errorStatus(ResponseConstants.SERVICE_NOT_ELASTIC,serviceName);
  }
  logger.info("Scaling " + puName + " to "+ count+ " instances");
  UUID eventContainerID;
  if (cloud == null) {
    if (isLocalCloud()) {
      pu.scale(new ManualCapacityScaleConfigurer().memoryCapacity(512 * count,MemoryUnit.MEGABYTES).create());
    }
 else {
      return errorStatus(ResponseConstants.SET_INSTANCES_NOT_SUPPORTED_IN_EAGER);
    }
  }
 else {
    final CloudTemplate template=getComputeTemplate(cloud,templateName);
    final long cloudExternalProcessMemoryInMB=calculateExternalProcessMemory(cloud,template);
    pu.scale(new ManualCapacityScaleConfigurer().memoryCapacity((int)(cloudExternalProcessMemoryInMB * count),MemoryUnit.MEGABYTES).atMostOneContainerPerMachine().create());
  }
  eventContainerID=startPollingForLifecycleEvents(serviceName,applicationName,count,false,timeout,TimeUnit.MINUTES);
  returnMap.put(CloudifyConstants.LIFECYCLE_EVENT_CONTAINER_ID,eventContainerID);
  return successStatus(returnMap);
}
