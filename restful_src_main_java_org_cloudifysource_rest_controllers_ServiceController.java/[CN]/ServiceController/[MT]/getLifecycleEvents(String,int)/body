{
  Map<String,Object> resultsMap=new HashMap<String,Object>();
  resultsMap.put(CloudifyConstants.POLLING_TIMEOUT_EXCEPTION,false);
  resultsMap.put(CloudifyConstants.POLLING_EXCEPTION,false);
  if (!lifecyclePollingContainer.containsKey(UUID.fromString(lifecycleEventContainerID))) {
    return errorStatus("Lifecycle events container with UUID: " + lifecycleEventContainerID + " does not exist or expired.");
  }
  LifecycleEventsContainer container=lifecyclePollingContainer.get(UUID.fromString(lifecycleEventContainerID));
  Future<?> futureTask=container.getFutureTask();
  PollingState runnableState=container.getPollingState();
switch (runnableState) {
case RUNNING:
    resultsMap.put(CloudifyConstants.IS_TASK_DONE,false);
  break;
case ENDED:
Throwable t=container.getExecutionException();
if (t != null) {
if (t.getCause() instanceof TimeoutException) {
  logger.log(Level.INFO,"Lifecycle events polling task timed out.");
  resultsMap.put(CloudifyConstants.POLLING_TIMEOUT_EXCEPTION,true);
  resultsMap.put(CloudifyConstants.IS_TASK_DONE,true);
}
 else {
  logger.log(Level.INFO,"Lifecycle events polling ended unexpectedly.",t);
  resultsMap.put(CloudifyConstants.POLLING_EXCEPTION,true);
  resultsMap.put(CloudifyConstants.IS_TASK_DONE,true);
}
}
 else {
logger.log(Level.INFO,"Lifecycle events polling ended successfully.");
resultsMap.put(CloudifyConstants.IS_TASK_DONE,true);
}
futureTask.cancel(true);
break;
}
List<String> lifecycleEvents=container.getLifecycleEvents(cursor);
if (lifecycleEvents != null) {
List<String> copy=new ArrayList<String>(lifecycleEvents);
int newCursorPos=cursor + lifecycleEvents.size();
resultsMap.put(CloudifyConstants.CURSOR_POS,newCursorPos);
resultsMap.put(CloudifyConstants.LIFECYCLE_LOGS,copy);
}
 else {
resultsMap.put(CloudifyConstants.CURSOR_POS,cursor);
}
if (runnableState.equals(PollingState.ENDED)) {
lifecyclePollingContainer.remove(UUID.fromString(lifecycleEventContainerID));
}
return successStatus(resultsMap);
}
