{
  Map<String,Object> resultsMap=new HashMap<String,Object>();
  resultsMap.put(CloudifyConstants.POLLING_EXCEPTION,false);
  if (!lifecyclePollingThreadContainer.containsKey(UUID.fromString(lifecycleEventContainerID))) {
    return errorStatus("Lifecycle events container with UUID: " + lifecycleEventContainerID + " does not exist or expired.");
  }
  RestPollingRunnable restPollingRunnable=lifecyclePollingThreadContainer.get(UUID.fromString(lifecycleEventContainerID));
  LifecycleEventsContainer container=restPollingRunnable.getLifecycleEventsContainer();
  PollingState runnableState=restPollingRunnable.getPollingState();
switch (runnableState) {
case RUNNING:
    extendThreadTimeout(restPollingRunnable,DEFAULT_TIME_EXTENTION_POLLING_TASK);
  resultsMap.put(CloudifyConstants.IS_TASK_DONE,false);
break;
case ENDED:
Throwable t=restPollingRunnable.getExecutionException();
if (t != null) {
logger.log(Level.INFO,"Lifecycle events polling ended unexpectedly.",t);
resultsMap.put(CloudifyConstants.POLLING_EXCEPTION,true);
resultsMap.put(CloudifyConstants.IS_TASK_DONE,true);
}
 else {
logger.log(Level.INFO,"Lifecycle events polling ended successfully.");
resultsMap.put(CloudifyConstants.IS_TASK_DONE,true);
}
break;
default :
return errorStatus("an unexpected error occurred. Polling task status is null.");
}
List<String> lifecycleEvents=container.getLifecycleEvents(cursor);
if (lifecycleEvents != null) {
int newCursorPos=cursor + lifecycleEvents.size();
resultsMap.put(CloudifyConstants.CURSOR_POS,newCursorPos);
resultsMap.put(CloudifyConstants.LIFECYCLE_LOGS,lifecycleEvents);
}
 else {
resultsMap.put(CloudifyConstants.CURSOR_POS,cursor);
}
long timeBeforeTaskTerminationMillis=restPollingRunnable.getEndTime() - System.currentTimeMillis();
resultsMap.put(CloudifyConstants.SERVER_POLLING_TASK_EXPIRATION_MILLI,Long.toString(timeBeforeTaskTerminationMillis));
return successStatus(resultsMap);
}
