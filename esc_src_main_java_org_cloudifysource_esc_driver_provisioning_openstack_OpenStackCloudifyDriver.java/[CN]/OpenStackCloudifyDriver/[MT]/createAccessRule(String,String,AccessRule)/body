{
  final PortRange portRange=PortRangeFactory.createPortRange(accessRule.getPortRange());
  String targetSecurityGroupId=serviceSecgroupId;
  String ip="0.0.0.0/0";
  String group=null;
switch (accessRule.getType()) {
case PUBLIC:
    break;
case SERVICE:
  group=this.openstackPrefixNames.getServiceName();
break;
case APPLICATION:
group=this.openstackPrefixNames.getApplicationName();
break;
case CLUSTER:
group=this.openstackPrefixNames.getClusterName();
break;
case GROUP:
group=accessRule.getTarget();
break;
case RANGE:
if (accessRule.getTarget() == null) {
throw new IllegalStateException("No IP defined for the 'Range' access rule type :" + accessRule);
}
ip=accessRule.getTarget();
break;
case PRIVATE:
default :
throw new IllegalStateException("Unsupported type of rule '" + accessRule.getType() + "'");
}
SecurityGroup existingSecgroup=null;
if (group != null) {
existingSecgroup=this.networkApi.getSecurityGroupsByName(group);
if (existingSecgroup == null) {
throw new IllegalStateException("Security group '" + group + "' does not exist.");
}
}
for (final PortRangeEntry pre : portRange.getRanges()) {
final SecurityGroupRule request=new SecurityGroupRule();
request.setDirection(direction);
request.setProtocol(DEFAULT_PROTOCOL);
request.setSecurityGroupId(targetSecurityGroupId);
request.setPortRangeMax(pre.getTo() == null ? pre.getFrom().toString() : pre.getTo().toString());
request.setPortRangeMin(pre.getFrom().toString());
if (existingSecgroup != null) {
request.setRemoteGroupId(existingSecgroup.getId());
}
 else {
request.setRemoteIpPrefix(ip);
}
networkApi.createSecurityGroupRule(request);
}
}
